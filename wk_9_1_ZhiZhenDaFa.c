/*
运算符&
    scanf &地址
    操作数必须为变量
        warnning 不一定
    直接输出会得到地址
    32bit和64bit
        int 和地址不同
    整数类型转换的原理
    使用%p输出地址，地址和整数不一定相同
&不能取的地址
    i++ i+p ++i
地址的顺序
    自顶向下 6c -> 68 c语言内存模型 堆栈stack
数组的地址
    &a = &a[0]  = &a[1] - 4
数组单元的地址 
相邻的数组单元的地址

有什么用
scanf
    变量地址传给某个函数，通过地址在那个函数内访问这个变量
        scanf("%d", &i);
    scanf()的原型是怎样，如何表达能保存地址的变量
指针
    保存地址的变量
    int i;
    int* p = &i;
    int* p, q;
    int *p, q;  //q只是普通类型变量，*实际加于p，没有int*类型
    指针存的是地址

指针变量
    变量的值是地址
    普通变量值是实际的值
    指针变量的值是具有实际值的变量的地址

作为参数的指针
    void f(int *p)
    调用时得到某个变量的地址
        int i = 0; f(&i);
    在函数内可以通过指针访问外面的这个i

访问地址上的变量*
    *是单目运算符，用来访问指针的值所表示地址上的变量
    可以做右值也可以作为左值
    int k = *p;
    *p = k + 1;

    *p = 26;
*左值为什么叫左值
    赋值号左边不是变量，而是值，是表达式计算的结果
    a[0] = 2;
    *p = 3;
    是特殊的值
指针的运算符 &*
    互相反作用
    *&yptr - *(&yptr) - *(yptr的地址) - 地址上的变量 - yptr
    &*yptr - &(*yptr) - &(y) - yptr
传入地址
    int i; scanf("%d", i); 
    不报错，32位，运行错
    32位，整数和地址一样大

*/

#include <stdio.h>

int main ()
{
    int i = 0; 
    int p;
    p = (int)&i; //类型转换
    printf("0x%x\n",p);
    printf("%p\n",&i);
    

    return 0;
}